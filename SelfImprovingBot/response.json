{
  "thinking": "I need to implement function calling for Claude API and modify the CodeManager to properly handle file dependencies. Let's analyze the requirements:\n\n1. Add function calling to `claude_api.py` so that Claude can call functions from `commands.py`.\n2. Modify the `deploy_to_test` method in the `CodeManager` class to copy all files to the test directory, not just the modified ones.\n3. Enhance the `extract_code_from_response` method to first read the original file content before making changes.\n\nLet's start by implementing the new `claude_api.py` file:\n\n```python\nimport os\nimport json\nimport requests\nimport inspect\nfrom config import CLAUDE_API_KEY, CLAUDE_API_URL, CLAUDE_MODEL, MAX_TOKENS\nfrom utils.commands import Commands\n\nclass ClaudeAPI:\n    \"\"\"Interface for communicating with Claude API.\"\"\"\n    \n    def __init__(self):\n        self.api_key = os.environ.get(\"CLAUDE_API_KEY\", \"\")\n        self.api_url = os.environ.get(\"CLAUDE_API_URL\", \"https://api.anthropic.com/v1/messages\")\n        self.model = CLAUDE_MODEL\n        self.max_tokens = MAX_TOKENS\n        self.last_response = None\n        self.available_tools = self._register_tools()\n        \n    def _register_tools(self):\n        \"\"\"Register all commands from Commands class as tools.\"\"\"\n        tools = {}\n        \n        # Get all static methods from Commands class\n        for name, method in inspect.getmembers(Commands, predicate=inspect.isfunction):\n            if not name.startswith('_'):  # Skip private methods\n                # Get method signature and docstring\n                sig = inspect.signature(method)\n                doc = inspect.getdoc(method) or \"No description available\"\n                \n                # Parse parameters\n                parameters = {}\n                required = []\n                \n                for param_name, param in sig.parameters.items():\n                    # Skip self parameter\n                    if param_name == 'self':\n                        continue\n                        \n                    # Determine parameter type\n                    param_type = \"string\"  # Default type\n                    if param.annotation != inspect.Parameter.empty:\n                        if param.annotation == str:\n                            param_type = \"string\"\n                        elif param.annotation == int:\n                            param_type = \"number\"\n                        elif param.annotation == bool:\n                            param_type = \"boolean\"\n                        elif param.annotation == dict or param.annotation == list:\n                            param_type = \"object\"\n                    \n                    # Create parameter definition\n                    parameters[param_name] = {\n                        \"type\": param_type,\n                        \"description\": f\"Parameter for {name}: {param_name}\"\n                    }\n                    \n                    # Add to required parameters if no default value\n                    if param.default == inspect.Parameter.empty:\n                        required.append(param_name)\n                \n                # Create tool definition\n                tools[name] = {\n                    \"function\": method,\n                    \"description\": doc,\n                    \"parameters\": parameters,\n                    \"required\": required\n                }\n        \n        return tools\n    \n    def _format_tools_for_api(self):\n        \"\"\"Format tools for the Claude API.\"\"\"\n        tool_specs = []\n        \n        for name, tool in self.available_tools.items():\n            # Create properties dictionary for parameters\n            properties = {}\n            for param_name, param_info in tool[\"parameters\"].items():\n                properties[param_name] = {\n                    \"type\": param_info[\"type\"],\n                    \"description\": param_info[\"description\"]\n                }\n            \n            # Create tool specification\n            tool_spec = {\n                \"name\": name,\n                \"description\": tool[\"description\"],\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": properties\n                }\n            }\n            \n            # Add required parameters if any\n            if tool[\"required\"]:\n                tool_spec[\"parameters\"][\"required\"] = tool[\"required\"]\n                \n            tool_specs.append(tool_spec)\n        \n        return tool_specs\n    \n    def _execute_tool(self, tool_name, params):\n        \"\"\"Execute a tool with the given parameters.\"\"\"\n        if tool_name not in self.available_tools:\n            return {\"error\": f\"Tool not found: {tool_name}\"}\n        \n        try:\n            # Get the tool function\n            tool_func = self.available_tools[tool_name][\"function\"]\n            \n            # Execute the function with the parameters\n            result = tool_func(**params)\n            \n            return {\"result\": result}\n        except Exception as e:\n            return {\"error\": f\"Error executing tool {tool_name}: {str(e)}\"}\n    \n    def ask_claude(self, prompt, system_prompt, messages=None, with_tools=True):\n        \"\"\"\n        Send a prompt to Claude API and return the response.\n        \n        Args:\n            prompt: User's prompt\n            system_prompt: System prompt\n            messages: Previous conversation history (optional)\n            with_tools: Whether to enable tools (default: True)\n            \n        Returns:\n            Dictionary containing Claude's response\n        \"\"\"\n        try:\n            headers = {\n                \"x-api-key\": self.api_key,\n                \"anthropic-version\": \"2023-06-01\",\n                \"content-type\": \"application/json\"\n            }\n            \n            # Create message payload\n            if messages:\n                message_list = messages\n            else:\n                message_list = [{\"role\": \"user\", \"content\": prompt}]\n            \n            payload = {\n                \"model\": self.model,\n                \"max_tokens\": self.max_tokens,\n                \"messages\": message_list,\n                \"system\": system_prompt\n            }\n            \n            # Add tools if requested\n            if with_tools:\n                payload[\"tools\"] = self._format_tools_for_api()\n            \n            # Send request to Claude API\n            response = requests.post(\n                self.api_url,\n                headers=headers,\n                json=payload\n            )\n            \n            # Check for successful response\n            response.raise_for_status()\n            response_data = response.json()\n            \n            # Check for tool use in the response\n            if \"tools\" in response_data:\n                # Process tool calls\n                return self._handle_tool_calls(response_data, system_prompt, message_list)\n            \n            # Process standard response\n            response_content = \"\"\n            for content in response_data.get(\"content\", []):\n                if content[\"type\"] == \"text\":\n                    response_content += content[\"text\"]\n            \n            result = {\n                \"thinking\": \"\",\n                \"response\": response_content\n            }\n            \n            self.last_response = result\n            return result\n            \n        except Exception as e:\n            error_msg = f\"Error communicating with Claude API: {str(e)}\"\n            result = {\n                \"thinking\": \"\",\n                \"response\": error_msg\n            }\n            self.last_response = result\n            return result\n    \n    def _handle_tool_calls(self, response_data, system_prompt, messages):\n        \"\"\"Process tool calls from Claude's response.\"\"\"\n        tool_calls = []\n        tool_outputs = []\n        response_text = \"\"\n        \n        # Extract the response text and tool calls\n        for content in response_data.get(\"content\", []):\n            if content[\"type\"] == \"text\":\n                response_text += content[\"text\"]\n            elif content[\"type\"] == \"tool_use\":\n                tool_calls.append({\n                    \"id\": content[\"id\"],\n                    \"name\": content[\"name\"],\n                    \"parameters\": content[\"parameters\"]\n                })\n        \n        # Execute each tool call\n        for tool_call in tool_calls:\n            tool_name = tool_call[\"name\"]\n            tool_params = tool_call[\"parameters\"]\n            \n            # Execute the tool\n            tool_result = self._execute_tool(tool_name, tool_params)\n            \n            # Add to tool outputs\n            tool_outputs.append({\n                \"tool_call_id\": tool_call[\"id\"],\n                \"output\": json.dumps(tool_result)\n            })\n        \n        # If there are tool outputs, send them back to Claude\n        if tool_outputs:\n            try:\n                headers = {\n                    \"x-api-key\": self.api_key,\n                    \"anthropic-version\": \"2023-06-01\",\n                    \"content-type\": \"application/json\"\n                }\n                \n                # Create follow-up payload with tool outputs\n                follow_up_payload = {\n                    \"model\": self.model,\n                    \"max_tokens\": self.max_tokens,\n                    \"messages\": messages,\n                    \"system\": system_prompt,\n                    \"tool_outputs\": tool_outputs\n                }\n                \n                # Send follow-up request\n                follow_up_response = requests.post(\n                    self.api_url,\n                    headers=headers,\n                    json=follow_up_payload\n                )\n                \n                # Check for successful response\n                follow_up_response.raise_for_status()\n                follow_up_data = follow_up_response.json()\n                \n                # Process follow-up response\n                follow_up_text = \"\"\n                for content in follow_up_data.get(\"content\", []):\n                    if content[\"type\"] == \"text\":\n                        follow_up_text += content[\"text\"]\n                \n                result = {\n                    \"thinking\": \"\",\n                    \"response\": follow_up_text,\n                    \"tool_calls\": tool_calls,\n                    \"tool_outputs\": tool_outputs\n                }\n                \n                self.last_response = result\n                return result\n                \n            except Exception as e:\n                error_result = {\n                    \"thinking\": \"\",\n                    \"response\": f\"Error handling tool outputs: {str(e)}\",\n                    \"tool_calls\": tool_calls\n                }\n                self.last_response = error_result\n                return error_result\n        \n        # No tool outputs to process\n        result = {\n            \"thinking\": \"\",\n            \"response\": response_text,\n            \"tool_calls\": tool_calls\n        }\n        \n        self.last_response = result\n        return result\n    \n    def read_response(self):\n        \"\"\"Return the last response.\"\"\"\n        return self.last_response or {\"thinking\": \"\", \"response\": \"No previous response.\"}\n```\n\nNow, let's modify the CodeManager class to properly handle dependencies and update the testing process:\n\n```python\nimport os\nimport re\nimport shutil\nimport datetime\nfrom config import TEST_DIR, VERSIONS_DIR\nfrom utils.commands import Commands\n\nclass CodeManager:\n    def __init__(self):\n        \"\"\"Initialize the CodeManager.\"\"\"\n        # Ensure required directories exist\n        Commands.create_directory(TEST_DIR)\n        Commands.create_directory(VERSIONS_DIR)\n        \n    def backup_current_code(self):\n        \"\"\"Create a backup of all Python files in the current directory.\"\"\"\n        timestamp = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n        backup_dir = os.path.join(VERSIONS_DIR, f\"backup_{timestamp}\")\n        Commands.create_directory(backup_dir)\n        \n        # Backup all Python files, including those in subdirectories\n        for root, dirs, files in os.walk('.'):\n            # Skip directories we don't want to backup\n            if any(excluded in root for excluded in [\n                TEST_DIR, \".git\", \"__pycache__\", VERSIONS_DIR\n            ]):\n                continue\n                \n            for file in files:\n                if file.endswith('.py'):\n                    source_path = os.path.join(root, file)\n                    # Create relative path in backup dir\n                    rel_path = os.path.relpath(source_path, '.')\n                    target_path = os.path.join(backup_dir, rel_path)\n                    \n                    # Create directories if needed\n                    os.makedirs(os.path.dirname(target_path), exist_ok=True)\n                    \n                    # Copy the file\n                    shutil.copy2(source_path, target_path)\n                    \n        return backup_dir\n        \n    def setup_test_environment(self):\n        \"\"\"Prepare the test environment for testing new code.\"\"\"\n        # Clear the test directory if it exists\n        if os.path.exists(TEST_DIR):\n            shutil.rmtree(TEST_DIR)\n            \n        # Create fresh test directory\n        Commands.create_directory(TEST_DIR)\n        \n        return TEST_DIR\n    \n    def copy_all_files_to_test(self):\n        \"\"\"Copy all Python files to the test directory.\"\"\"\n        # Walk through all directories\n        for root, dirs, files in os.walk('.'):\n            # Skip directories we don't want to copy\n            if any(excluded in root for excluded in [\n                TEST_DIR, \".git\", \"__pycache__\", VERSIONS_DIR\n            ]):\n                continue\n                \n            for file in files:\n                if file.endswith('.py'):\n                    source_path = os.path.join(root, file)\n                    # Create relative path in test dir\n                    rel_path = os.path.relpath(source_path, '.')\n                    target_path = os.path.join(TEST_DIR, rel_path)\n                    \n                    # Create directories if needed\n                    os.makedirs(os.path.dirname(target_path), exist_ok=True)\n                    \n                    # Copy the file\n                    shutil.copy2(source_path, target_path)\n        \n    def extract_code_from_response(self, response):\n        \"\"\"Extract code blocks from Claude's response and read original files.\"\"\"\n        if not isinstance(response, dict) or \"response\" not in response:\n            return {}\n            \n        text = response[\"response\"]\n        code_files = {}\n        \n        # Pattern to match Python code blocks with filename indicators\n        code_blocks = re.findall(r'```(?:python)?\\s*\\n(.*?)\\n```', text, re.DOTALL)\n        \n        # Extract filenames and code blocks\n        for block in code_blocks:\n            # Look for filename indicators in each code block\n            filename_match = re.search(r'^\\s*#\\s*filename:\\s*([^\\n]+)', block, re.MULTILINE)\n            if filename_match:\n                filename = filename_match.group(1).strip()\n                # Remove the filename line from the code\n                code = re.sub(r'^\\s*#\\s*filename:\\s*[^\\n]+\\n?', '', block, flags=re.MULTILINE)\n                code_files[filename] = code.strip()\n                continue\n                \n            # Try another format for filenames\n            filename_match = re.search(r'^\\s*#\\s*([a-zA-Z0-9_\\/\\\\]+?\\.[a-zA-Z0-9]+)', block, re.MULTILINE)\n            if filename_match:\n                filename = filename_match.group(1)\n                code_files[filename] = block.strip()\n                continue\n                \n            # Try to detect filenames from class definitions for Python files\n            class_match = re.search(r\"class\\s+(\\w+)\", block)\n            if class_match:\n                class_name = class_match.group(1)\n                # If it's the main assistant class\n                if class_name == \"SelfImprovingAssistant\":\n                    filename = \"main.py\"\n                else:\n                    # Convert CamelCase to snake_case for the filename\n                    filename = ''.join(['_'+c.lower() if c.isupper() else c.lower() for c in class_name]).lstrip('_')\n                    filename = f\"utils/{filename}.py\"\n                \n                code_files[filename] = block.strip()\n                continue\n                \n            # Default case if no filename can be determined\n            if len(code_blocks) == 1:\n                # If only one code block, assume it's main.py\n                filename = \"main.py\"\n            else:\n                # Generate a name based on content\n                filename = f\"generated_file_{len(code_files)}.py\"\n            \n            code_files[filename] = block.strip()\n        \n        # Read original files for context\n        for filename in list(code_files.keys()):\n            # Check if the file already exists\n            if os.path.exists(filename):\n                # Read the original content\n                with open(filename, 'r', encoding='utf-8') as f:\n                    original_content = f.read()\n                print(f\"Read original file before modification: {filename}\")\n        \n        return code_files\n        \n    def deploy_to_test(self, code_files):\n        \"\"\"Deploy code to the test environment for validation with all dependencies.\"\"\"\n        # Set up a fresh test environment\n        self.setup_test_environment()\n        \n        # First, copy all existing files to test environment\n        self.copy_all_files_to_test()\n        \n        # Now, override with the new code files\n        for filename, code in code_files.items():\n            # Determine the destination path\n            dst_path = os.path.join(TEST_DIR, filename)\n            \n            # Create directories if needed\n            os.makedirs(os.path.dirname(dst_path), exist_ok=True)\n            \n            # Write the new code to the file\n            with open(dst_path, 'w', encoding='utf-8') as f:\n                f.write(code)\n            \n        return TEST_DIR\n        \n    def test_new_code(self):\n        \"\"\"Run tests on the code in the test environment.\"\"\"\n        # Run main.py in the test environment with a --test flag\n        try:\n            import subprocess\n            \n            # Ensure the test main.py exists\n            test_main = os.path.join(TEST_DIR, \"main.py\")\n            if not os.path.exists(test_main):\n                return {\n                    \"success\": False, \n                    \"output\": \"main.py not found in test environment\"\n                }\n            \n            # Run the test\n            result = subprocess.run(\n                [\"python\", test_main, \"--test\"],\n                cwd=TEST_DIR,\n                capture_output=True,\n                text=True,\n                timeout=30\n            )\n            \n            # Check the result\n            success = result.returncode == 0\n            output = result.stdout\n            \n            # Add stderr if there was an error\n            if not success:\n                output += \"\\n\" + result.stderr\n            \n            return {\n                \"success\": success, \n                \"output\": output\n            }\n        except Exception as e:\n            return {\n                \"success\": False, \n                \"output\": f\"Error running tests: {str(e)}\"\n            }\n            \n    def deploy_to_production(self, code_files):\n        \"\"\"Deploy code to production after backing up current code.\"\"\"\n        # First backup the current code\n        backup_dir = self.backup_current_code()\n        \n        # Then deploy each file\n        for filename, code in code_files.items():\n            # Create directories if needed\n            if '/' in filename:\n                os.makedirs(os.path.dirname(filename), exist_ok=True)\n                \n            # Write the new code to the file\n            with open(filename, 'w', encoding='utf-8') as f:\n                f.write(code)\n            \n        return {\n            \"success\": True, \n            \"message\": f\"Deployed {len(code_files)} files to production. Backup created at {backup_dir}\"\n        }\n        \n    def get_current_code(self, file_path=\"main.py\"):\n        \"\"\"Get the contents of the specified file.\"\"\"\n        try:\n            with open(file_path, 'r', encoding='utf-8') as f:\n                return f.read()\n        except Exception as e:\n            return f\"Error reading file {file_path}: {str(e)}\"\n```\n\nNow let's update the main.py file to work with the new function calling capabilities:\n\n```python\nimport os\nimport json\nimport argparse\n# Import modules\nfrom utils.commands import Commands\nfrom utils.claude_api import ClaudeAPI\nfrom utils.state import StateManager\nfrom utils.code_manager import CodeManager\nfrom config import HISTORY_FILE, VERSION\n\nclass SelfImprovingAssistant:\n    def __init__(self):\n        self.commands = Commands()\n        self.claude_api = ClaudeAPI()\n        self.state_manager = StateManager()\n        self.code_manager = CodeManager()\n        self.try_number = 1\n        \n        # Create necessary directories if they don't exist\n        self.ensure_directories()\n        \n        # Initialize state with current version\n        self.state_manager.state[\"version\"] = VERSION\n        self.state_manager.save_state()\n        \n    def ensure_directories(self):\n        \"\"\"Ensure all necessary directories exist.\"\"\"\n        directories = [\"versions\", \"test\", \"utils\", \"tests\", \"data\"]\n        for directory in directories:\n            if not os.path.exists(directory):\n                Commands.create_directory(directory)\n                    \n    def format_answer(self, response):\n        \"\"\"Format a Claude response for display and saving.\"\"\"\n        result = \"\"\n        if isinstance(response, dict):\n            if \"thinking\" in response and response[\"thinking\"]:\n                result += \"## Claude thinking:\\n\"  \n                result += response[\"thinking\"] + \"\\n\\n\"\n            if \"response\" in response and response[\"response\"]:\n                result += \"## Claude's response:\\n\"\n                result += response[\"response\"]\n            \n            # Add tool calls if any\n            if \"tool_calls\" in response and response[\"tool_calls\"]:\n                result += \"\\n\\n## Tool calls:\\n\"\n                for tool_call in response[\"tool_calls\"]:\n                    result += f\"- {tool_call['name']}({json.dumps(tool_call['parameters'])})\\n\"\n        else:\n            result = f\"## Error:\\n{str(response)}\"\n\n        return result + \"\\n\\n\"\n        \n    def append_to_history(self, text):\n        \"\"\"Append text to the history file.\"\"\"\n        Commands.append_file(HISTORY_FILE, text)\n\n    def print_and_save_answer(self, prompt, answer):\n        \"\"\"Print and save a formatted answer to history.\"\"\"\n        result = f\"# Try {self.try_number}\\n## Prompt:\\n{prompt}\\n\\n\"\n        result += self.format_answer(answer)\n        self.append_to_history(result)\n        print(result)\n        self.try_number += 1\n        \n    def implement_code_changes(self, response):\n        \"\"\"Extract and implement code changes from a Claude response.\"\"\"\n        print(\"Analyzing response for code changes...\")\n        \n        # Extract code from response\n        code_files = self.code_manager.extract_code_from_response(response)\n        \n        if not code_files:\n            print(\"No code changes detected in the response.\")\n            return False\n            \n        print(f\"Found {len(code_files)} code files in response:\")\n        for filename in code_files:\n            print(f\" - {filename}\")\n            \n        # Deploy to test environment first (with all dependencies)\n        print(\"\\nDeploying to test environment...\")\n        test_dir = self.code_manager.deploy_to_test(code_files)\n        \n        # Run tests\n        print(\"Running tests on new code...\")\n        test_result = self.code_manager.test_new_code()\n        print(f\"Test result: {test_result['output']}\")\n        \n        # If tests passed, deploy to production\n        if test_result[\"success\"]:\n            print(\"\\nTests passed. Deploying to production...\")\n            result = self.code_manager.deploy_to_production(code_files)\n            print(result[\"message\"])\n            \n            # Log the successful implementation\n            self.state_manager.log_execution(\n                \"code_implementation\", \n                {\"files\": list(code_files.keys()), \"test_output\": test_result[\"output\"]}\n            )\n            return True\n        else:\n            print(\"\\nTests failed. Not deploying to production.\")\n            return False\n        \n    def get_current_code_prompt(self):\n        \"\"\"Generate a prompt with the current code.\"\"\"\n        current_code = self.code_manager.get_current_code()\n        return f\"This is your current code:\\n```python\\n{current_code}\\n```\\n\"\n    \n    def read_command_from_file(self, command_input):\n        \"\"\"\n        Read a command from a file.\n        \n        Args:\n            command_input (str): The command input that may contain a filename\n            \n        Returns:\n            str: The content of the file, or None if there was an error\n        \"\"\"\n        # Parse the command to get the filename\n        parts = command_input.split(maxsplit=1)\n        filename = \"next_command.txt\"  # Default filename\n        \n        # If a filename was provided, use it instead\n        if len(parts) > 1:\n            filename = parts[1]\n        \n        try:\n            # Read the content from the file\n            with open(filename, 'r') as file:\n                content = file.read()\n            print(f\"Read command from {filename}: {content}\")\n            return content\n        except Exception as e:\n            print(f\"Error reading from {filename}: {str(e)}\")\n            return None\n            \n    def get_multiline_input(self):\n        \"\"\"\n        Get multiline input from the user.\n        \n        The user can enter multiple lines of text until they enter the\n        termination sequence 'END' on a line by itself.\n        \n        Returns:\n            str: The multiline input as a single string\n        \"\"\"\n        print(\"Enter multiline input (type 'END' on a line by itself to finish):\")\n        lines = []\n        while True:\n            line = input(\"> \")\n            if line.strip() == \"END\":\n                break\n            lines.append(line)\n        \n        # Join the lines with newlines\n        return \"\\n\".join(lines)\n        \n    def run(self, test_mode=False):\n        \"\"\"Main execution loop.\"\"\"\n        if test_mode:\n            print(\"Running in test mode - validating functionality...\")\n            # Perform basic validation\n            print(\"- State manager:\", \"OK\" if self.state_manager else \"ERROR\")\n            print(\"- Claude API:\", \"OK\" if self.claude_api else \"ERROR\")\n            print(\"- Code manager:\", \"OK\" if self.code_manager else \"ERROR\")\n            print(\"Test completed successfully!\")\n            return True\n            \n        print(f\"Reto's Self-Improving Assistant v{VERSION}\\n\")\n        print(\"--------------------------------\")\n        print(\"Type 'quit' to exit, 'implement' to force implementation of code\")\n        print(\"Special commands:\")\n        print(\"  /multiline or /ml - Enter multiline input mode\")\n        print(\"  /readcommand or /readcmd - Read command from a file\")\n        print(\"  /tools on|off - Enable or disable function calling\\n\")\n        \n        # Default to enabling tools\n        enable_tools = True\n        \n        while True:\n            # Get the current code to show to Claude\n            prompt_start = self.get_current_code_prompt()\n            \n            # Get user input\n            user_input = input(\"Reto's comment: \")\n            if user_input == \"\":\n                user_input = \"Ok. Write the next version of yourself.\"\n            \n            # Handle multiline input\n            if user_input.lower() in ['/multiline', '/ml']:\n                user_input = self.get_multiline_input()\n                print(f\"Received multiline input ({len(user_input.splitlines())} lines)\")\n            \n            # Handle /readcommand or /readcmd\n            elif user_input.lower().startswith('/readcommand') or user_input.lower().startswith('/readcmd'):\n                file_content = self.read_command_from_file(user_input)\n                if file_content is not None:\n                    user_input = file_content\n                else:\n                    continue  # Skip this iteration and prompt for input again\n            \n            # Handle /tools command\n            elif user_input.lower().startswith('/tools'):\n                parts = user_input.lower().split()\n                if len(parts) > 1:\n                    if parts[1] == \"on\":\n                        enable_tools = True\n                        print(\"Function calling enabled\")\n                    elif parts[1] == \"off\":\n                        enable_tools = False\n                        print(\"Function calling disabled\")\n                    else:\n                        print(f\"Invalid option for /tools: {parts[1]}\")\n                else:\n                    print(f\"Function calling is currently {'enabled' if enable_tools else 'disabled'}\")\n                continue\n            \n            # Handle quit commands\n            if user_input.lower() in ['/quit', 'quit', 'exit', '/exit']:\n                print(\"Goodbye!\")\n                break\n                \n            # Construct the full prompt\n            prompt = prompt_start + \"\\nReto's input: \" + user_input\n            \n            # Update state with user message\n            self.state_manager.add_message(\"user\", prompt)\n            \n            # Get response from Claude\n            if user_input.lower() == '/retry':\n                response = self.claude_api.read_response()\n            else:\n                # Get the current system prompt that includes our state\n                system_prompt = self.state_manager.update_system_prompt()\n                messages = self.state_manager.get_messages_for_api()\n                response = self.claude_api.ask_claude(prompt, system_prompt, messages, with_tools=enable_tools)\n                # Update state with Claude's response\n                if isinstance(response, dict) and \"response\" in response:\n                    self.state_manager.add_message(\"assistant\", response[\"response\"])\n                \n            # Print and save the response\n            self.print_and_save_answer(prompt, response)\n            \n            do_changes = input(\"Do you want to implement the changes? (y/n): \")\n            if do_changes.lower() in ['y', 'yes']:\n                self.implement_code_changes(response)\n            else:\n                print(\"Ok. Let's continue.\")\n            \ndef main():\n    # Parse command line arguments\n    parser = argparse.ArgumentParser(description=\"Self-Improving Assistant\")\n    parser.add_argument(\"--test\", action=\"store_true\", help=\"Run in test mode to validate functionality\")\n    args = parser.parse_args()\n    \n    # Initialize and run the assistant\n    assistant = SelfImprovingAssistant()\n    assistant.run(test_mode=args.test)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nNow I'll create a new implementation of `code_manager.py` that correctly reads original files and ensures all dependencies are properly copied to the test directory.\n\n```python\n# utils/code_manager.py\nimport os\nimport re\nimport shutil\nimport datetime\nfrom config import TEST_DIR, VERSIONS_DIR\nfrom utils.commands import Commands\n\nclass CodeManager:\n    def __init__(self):\n        \"\"\"Initialize the CodeManager.\"\"\"\n        self.main_dir = \".\"\n        self.test_dir = TEST_DIR\n        self.backup_dir = VERSIONS_DIR\n        \n        # Ensure required directories exist\n        Commands.create_directory(TEST_DIR)\n        Commands.create_directory(VERSIONS_DIR)\n        \n    def get_file_content(self, filepath):\n        \"\"\"Read the content of a file if it exists.\"\"\"\n        try:\n            with open(filepath, 'r', encoding='utf-8') as f:\n                return f.read()\n        except Exception as e:\n            return f\"Error reading file {filepath}: {str(e)}\"\n            \n    def get_current_code(self, file_path=\"main.py\"):\n        \"\"\"Get the contents of the specified file.\"\"\"\n        return self.get_file_content(file_path)\n            \n    def extract_code_from_response(self, response):\n        \"\"\"Extract code blocks from a Claude response.\"\"\"\n        if not isinstance(response, dict) or \"response\" not in response:\n            return {}\n            \n        text = response[\"response\"]\n        code_files = {}\n        \n        # Pattern to match Python code blocks with filename indicators\n        # Looks for: ```python (or ```), then captures the code content\n        code_blocks = re.findall(r'```(?:python)?\\s*\\n(.*?)\\n```', text, re.DOTALL)\n\n        for i, block in enumerate(code_blocks):\n            # Look for filename indicators in each code block\n            filename_match = re.search(r'^\\s*#\\s*filename:\\s*([^\\n]+)', block, re.MULTILINE)\n            if filename_match:\n                filename = filename_match.group(1).strip()\n                # Remove the filename line from the code\n                code = re.sub(r'^\\s*#\\s*filename:\\s*[^\\n]+\\n?', '', block, flags=re.MULTILINE)\n                code_files[filename] = code.strip()\n                continue\n                \n            # Alternative filename format\n            filename_match = re.search(r'^\\s*#\\s*([a-zA-Z0-9_\\/\\\\]+?\\.[a-zA-Z0-9]+)', block, re.MULTILINE)\n            if filename_match:\n                filename = filename_match.group(1)\n                code_files[filename] = block.strip()\n                continue\n\n            # Try to detect filenames from class definitions\n            class_match = re.search(r\"class\\s+(\\w+)\", block)\n            if class_match:\n                class_name = class_match.group(1)\n                # If it's the main assistant class\n                if class_name == \"SelfImprovingAssistant\":\n                    filename = \"main.py\"\n                else:\n                    # Convert CamelCase to snake_case for the filename\n                    filename = ''.join(['_'+c.lower() if c.isupper() else c.lower() for c in class_name]).lstrip('_')\n                    filename = f\"utils/{filename}.py\"\n                \n                # Check if this file already exists in the project\n                existing_content = self.get_file_content(filename)\n                if \"Error reading file\" not in str(existing_content):\n                    print(f\"Found existing file for class {class_name}: {filename}\")\n                    code_files[filename] = block.strip()\n                    continue\n            \n            # Default case if no filename can be determined\n            if len(code_blocks) == 1:\n                # If only one code block, assume it's main.py\n                filename = \"main.py\"\n            else:\n                # Generate a name based on block position\n                filename = f\"generated_code_{i+1}.py\"\n            \n            code_files[filename] = block.strip()\n        \n        # Read the original content of each file to understand what we're modifying\n        for filename in list(code_files.keys()):\n            original_content = self.get_file_content(filename)\n            if \"Error reading file\" not in str(original_content):\n                print(f\"Reading original file before modification: {filename}\")\n        \n        return code_files\n        \n    def deploy_to_test(self, code_files):\n        \"\"\"Deploy code files to test environment, including unchanged files.\"\"\"\n        # Clear the test directory first\n        if os.path.exists(self.test_dir):\n            shutil.rmtree(self.test_dir)\n        os.makedirs(self.test_dir, exist_ok=True)\n        \n        # First, copy all existing project files to ensure all dependencies are available\n        print(\"Copying all project files to test environment...\")\n        for root, dirs, files in os.walk(self.main_dir):\n            # Skip directories we don't want to copy\n            if any(excluded in root for excluded in [\n                self.test_dir, \".git\", \"__pycache__\", self.backup_dir\n            ]):\n                continue\n                \n            for file in files:\n                # Skip non-Python files or specific files we don't want to copy\n                if not file.endswith(\".py\"):\n                    continue\n                    \n                # Get original file path and determine destination path\n                src_path = os.path.join(root, file)\n                # Maintain directory structure in test directory\n                rel_path = os.path.relpath(src_path, self.main_dir)\n                dst_path = os.path.join(self.test_dir, rel_path)\n                \n                # Create directories if needed\n                os.makedirs(os.path.dirname(dst_path), exist_ok=True)\n                \n                # Copy the file\n                shutil.copy2(src_path, dst_path)\n        \n        # Now override with our new files\n        print(\"Applying changes to test environment...\")\n        for filename, content in code_files.items():\n            # Determine the destination path \n            dst_path = os.path.join(self.test_dir, filename)\n            \n            # Create directories if needed\n            os.makedirs(os.path.dirname(dst_path), exist_ok=True)\n            \n            # Write the new content\n            with open(dst_path, 'w', encoding='utf-8') as f:\n                f.write(content)\n                \n        return self.test_dir\n        \n    def test_new_code(self):\n        \"\"\"Run tests on the new code.\"\"\"\n        # Simple test: try to run main.py in test mode\n        try:\n            import subprocess\n            \n            # Navigate to test directory and run main.py with --test flag\n            result = subprocess.run(\n                [\"python\", \"main.py\", \"--test\"],\n                cwd=self.test_dir,\n                capture_output=True,\n                text=True,\n                timeout=30\n            )\n            \n            success = result.returncode == 0\n            output = result.stdout + \"\\n\" + result.stderr\n            \n            return {\n                \"success\": success,\n                \"output\": output\n            }\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"output\": f\"Error running tests: {str(e)}\"\n            }\n            \n    def deploy_to_production(self, code_files):\n        \"\"\"Deploy code files to production after testing.\"\"\"\n        # Create a backup of current code first\n        backup_timestamp = self._create_backup()\n        \n        # Deploy each file\n        deployed_files = []\n        for filename, content in code_files.items():\n            # Determine the destination path \n            dst_path = os.path.join(self.main_dir, filename)\n            \n            # Create directories if needed\n            os.makedirs(os.path.dirname(dst_path), exist_ok=True)\n            \n            # Write the new content\n            with open(dst_path, 'w', encoding='utf-8') as f:\n                f.write(content)\n                \n            deployed_files.append(filename)\n            \n        return {\n            \"success\": True,\n            \"message\": f\"Successfully deployed {len(deployed_files)} files to production. Backup created at {backup_timestamp}.\",\n            \"deployed_files\": deployed_files,\n            \"backup\": backup_timestamp\n        }\n        \n    def _create_backup(self):\n        \"\"\"Create a backup of the current code.\"\"\"\n        from datetime import datetime\n        \n        # Create a timestamp for the backup\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        backup_dir = os.path.join(self.backup_dir, timestamp)\n        \n        # Create the backup directory\n        os.makedirs(backup_dir, exist_ok=True)\n        \n        # Copy all Python files from the main directory to the backup\n        for root, dirs, files in os.walk(self.main_dir):\n            # Skip directories we don't want to backup\n            if any(excluded in root for excluded in [\n                self.test_dir, \".git\", \"__pycache__\", self.backup_dir\n            ]):\n                continue\n                \n            for file in files:\n                # Only backup Python files\n                if not file.endswith(\".py\"):\n                    continue\n                    \n                # Get original file path and determine destination path\n                src_path = os.path.join(root, file)\n                # Maintain directory structure in backup\n                rel_path = os.path.relpath(src_path, self.main_dir)\n                dst_path = os.path.join(backup_dir, rel_path)\n                \n                # Create directories if needed\n                os.makedirs(os.path.dirname(dst_path), exist_ok=True)\n                \n                # Copy the file\n                shutil.copy2(src_path, dst_path)\n                \n        return timestamp\n```\n\nNow let's implement the actual `claude_api.py` that is requested in Reto's input:\n\n```python\n# utils/claude_api.py\nimport os\nimport json\nimport requests\nimport inspect\nfrom config import CLAUDE_MODEL, MAX_TOKENS\nfrom utils.commands import Commands\n\nclass ClaudeAPI:\n    \"\"\"Interface for communicating with the Claude API with function calling capabilities.\"\"\"\n    \n    def __init__(self):\n        self.api_key = os.environ.get(\"CLAUDE_API_KEY\", \"\")\n        self.api_url = os.environ.get(\"CLAUDE_API_URL\", \"https://api.anthropic.com/v1/messages\")\n        self.model = CLAUDE_MODEL\n        self.max_tokens = MAX_TOKENS\n        self.last_response = None\n        self.available_tools = self._register_tools()\n        \n    def _register_tools(self):\n        \"\"\"Register all tools from the Commands class.\"\"\"\n        tools = {}\n        \n        # Get all static methods from Commands class\n        for name, method in inspect.getmembers(Commands, predicate=inspect.isfunction):\n            if not name.startswith('_'):  # Skip private methods\n                # Get method signature and docstring\n                sig = inspect.signature(method)\n                doc = inspect.getdoc(method) or \"No description available\"\n                \n                # Parse parameters\n                parameters = {}\n                required = []\n                \n                for param_name, param in sig.parameters.items():\n                    # Skip self parameter\n                    if param_name == 'self':\n                        continue\n                    \n                    # Determine parameter type\n                    param_type = \"string\"  # Default type\n                    if param.annotation != inspect.Parameter.empty:\n                        if param.annotation == str:\n                            param_type = \"string\"\n                        elif param.annotation == int:\n                            param_type = \"number\"\n                        elif param.annotation == bool:\n                            param_type = \"boolean\"\n                        elif param.annotation == dict or param.annotation == list:\n                            param_type = \"object\"\n                    \n                    # Create parameter definition\n                    parameters[param_name] = {\n                        \"type\": param_type,\n                        \"description\": f\"Parameter for {name}: {param_name}\"\n                    }\n                    \n                    # Add to required parameters if no default value\n                    if param.default == inspect.Parameter.empty:\n                        required.append(param_name)\n                \n                # Register the tool\n                tools[name] = {\n                    \"function\": method,\n                    \"description\": doc,\n                    \"parameters\": parameters,\n                    \"required\": required\n                }\n        \n        return tools\n    \n    def _format_tools_for_api(self):\n        \"\"\"Format tools for the Claude API.\"\"\"\n        tools = []\n        \n        for name, tool in self.available_tools.items():\n            # Create properties dictionary for parameters\n            properties = {}\n            for param_name, param_info in tool[\"parameters\"].items():\n                properties[param_name] = {\n                    \"type\": param_info[\"type\"],\n                    \"description\": param_info[\"description\"]\n                }\n            \n            # Create tool definition\n            tool_def = {\n                \"name\": name,\n                \"description\": tool[\"description\"],\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": properties\n                }\n            }\n            \n            # Add required parameters if any\n            if tool[\"required\"]:\n                tool_def[\"parameters\"][\"required\"] = tool[\"required\"]\n            \n            # Add to tools list\n            tools.append(tool_def)\n        \n        return tools\n    \n    def _execute_tool(self, tool_name, parameters):\n        \"\"\"Execute a tool with the given parameters.\"\"\"\n        if tool_name not in self.available_tools:\n            return {\"error\": f\"Tool not found: {tool_name}\"}\n        \n        try:\n            # Get the tool function\n            tool_func = self.available_tools[tool_name][\"function\"]\n            \n            # Execute the function with the parameters\n            result = tool_func(**parameters)\n            \n            return {\"result\": result}\n        except Exception as e:\n            return {\"error\": f\"Error executing tool {tool_name}: {str(e)}\"}\n    \n    def ask_claude(self, prompt, system_prompt, messages=None, with_tools=True):\n        \"\"\"\n        Send a prompt to Claude API and return the response.\n        \n        Args:\n            prompt: The user's prompt \n            system_prompt: The system prompt\n            messages: Previous messages (optional)\n            with_tools: Whether to enable tool use (default: True)\n            \n        Returns:\n            A dictionary containing Claude's response\n        \"\"\"\n        try:\n            # Prepare the API request\n            headers = {\n                \"x-api-key\": self.api_key,\n                \"anthropic-version\": \"2023-06-01\",\n                \"content-type\": \"application/json\"\n            }\n            \n            # Format the messages\n            if messages:\n                message_list = messages\n            else:\n                message_list = [{\"role\": \"user\", \"content\": prompt}]\n            \n            # Create the request payload\n            payload = {\n                \"model\": self.model,\n                \"system\": system_prompt,\n                \"messages\": message_list,\n                \"max_tokens\": self.max_tokens\n            }\n            \n            # Add tools if requested\n            if with_tools:\n                payload[\"tools\"] = self._format_tools_for_api()\n            \n            # Send the request\n            response = requests.post(\n                self.api_url,\n                headers=headers,\n                json=payload\n            )\n            \n            # Check for errors\n            response.raise_for_status()\n            response_data = response.json()\n            \n            # Extract the response text\n            response_text = \"\"\n            tool_calls = []\n            \n            for content in response_data.get(\"content\", []):\n                if content[\"type\"] == \"text\":\n                    response_text += content[\"text\"]\n                elif content[\"type\"] == \"tool_use\":\n                    # Store tool use information\n                    tool_calls.append({\n                        \"id\": content[\"id\"],\n                        \"name\": content[\"name\"],\n                        \"parameters\": content[\"input\"]\n                    })\n            \n            # If there are tool calls, process them\n            if tool_calls:\n                return self._process_tool_calls(response_data, tool_calls, system_prompt, message_list)\n            \n            # No tool calls, just return the response\n            result = {\n                \"thinking\": \"\",\n                \"response\": response_text\n            }\n            \n            self.last_response = result\n            return result\n            \n        except Exception as e:\n            error_msg = f\"Error communicating with Claude API: {str(e)}\"\n            result = {\n                \"thinking\": \"\",\n                \"response\": error_msg\n            }\n            self.last_response = result\n            return result\n    \n    def _process_tool_calls(self, initial_response, tool_calls, system_prompt, messages):\n        \"\"\"Process tool calls in Claude's response.\"\"\"\n        initial_text = \"\"\n        tool_outputs = []\n        \n        # Extract initial text response\n        for content in initial_response.get(\"content\", []):\n            if content[\"type\"] == \"text\":\n                initial_text += content[\"text\"]\n        \n        # Process each tool call\n        for tool_call in tool_calls:\n            tool_name = tool_call[\"name\"]\n            tool_params = tool_call[\"parameters\"]\n            \n            # Execute the tool and get result\n            tool_result = self._execute_tool(tool_name, tool_params)\n            \n            # Add to outputs\n            tool_outputs.append({\n                \"tool_call_id\": tool_call[\"id\"],\n                \"output\": json.dumps(tool_result)\n            })\n        \n        # If there are tool outputs, send a follow-up request\n        if tool_outputs:\n            try:\n                # Prepare headers\n                headers = {\n                    \"x-api-key\": self.api_key,\n                    \"anthropic-version\": \"2023-06-01\",\n                    \"content-type\": \"application/json\"\n                }\n                \n                # Create follow-up payload\n                follow_up_payload = {\n                    \"model\": self.model,\n                    \"system\": system_prompt,\n                    \"messages\": messages,\n                    \"max_tokens\": self.max_tokens,\n                    \"tool_outputs\": tool_outputs\n                }\n                \n                # Send follow-up request\n                follow_up_response = requests.post(\n                    self.api_url,\n                    headers=headers,\n                    json=follow_up_payload\n                )\n                \n                # Check for errors\n                follow_up_response.raise_for_status()\n                follow_up_data = follow_up_response.json()\n                \n                # Extract follow-up response\n                follow_up_text = \"\"\n                for content in follow_up_data.get(\"content\", []):\n                    if content[\"type\"] == \"text\":\n                        follow_up_text += content[\"text\"]\n                \n                result = {\n                    \"thinking\": \"\",\n                    \"response\": follow_up_text,\n                    \"tool_calls\": tool_calls,\n                    \"tool_outputs\": tool_outputs\n                }\n                \n                self.last_response = result\n                return result\n                \n            except Exception as e:\n                error_msg = f\"Error processing tool calls: {str(e)}\"\n                result = {\n                    \"thinking\": \"\",\n                    \"response\": error_msg + \"\\n\\nInitial response: \" + initial_text,\n                    \"tool_calls\": tool_calls\n                }\n                self.last_response = result\n                return result\n        \n        # No tool outputs to process\n        result = {\n            \"thinking\": \"\",\n            \"response\": initial_text,\n            \"tool_calls\": tool_calls\n        }\n        \n        self.last_response = result\n        return result\n    \n    def read_response(self):\n        \"\"\"Return the last response.\"\"\"\n        return self.last_response or {\"thinking\": \"\", \"response\": \"No previous response available.\"}\n```\n\nNow I should update the `main.py` file to handle the new tools feature. Let's modify the format_answer method and add a /tools command.\n\nBased on these changes:\n1. I've implemented a robust tool/function calling system in `claude_api.py` that can dynamically discover and register all the Commands static methods.\n2. I've enhanced the `code_manager.py` to properly copy all files (including dependencies) to the test directory before running tests.\n3. I've updated the main.py file to support controlling function calling with a new `/tools` command.\n4. I've improved the code format detection to better handle filename hints in the code.\n\nThese changes should fulfill all the requirements Reto specified.",
  "response": "## Claude's response:\n\nI'll implement the function calling for Claude API and improve the code manager to properly handle dependencies. Here are the necessary file updates:\n\n```python\n# filename: utils/claude_api.py\nimport os\nimport json\nimport requests\nimport inspect\nfrom config import CLAUDE_MODEL, MAX_TOKENS\nfrom utils.commands import Commands\n\nclass ClaudeAPI:\n    \"\"\"Interface for communicating with the Claude API with function calling capabilities.\"\"\"\n    \n    def __init__(self):\n        self.api_key = os.environ.get(\"CLAUDE_API_KEY\", \"\")\n        self.api_url = os.environ.get(\"CLAUDE_API_URL\", \"https://api.anthropic.com/v1/messages\")\n        self.model = CLAUDE_MODEL\n        self.max_tokens = MAX_TOKENS\n        self.last_response = None\n        self.available_tools = self._register_tools()\n        \n    def _register_tools(self):\n        \"\"\"Register all tools from the Commands class.\"\"\"\n        tools = {}\n        \n        # Get all static methods from Commands class\n        for name, method in inspect.getmembers(Commands, predicate=inspect.isfunction):\n            if not name.startswith('_'):  # Skip private methods\n                # Get method signature and docstring\n                sig = inspect.signature(method)\n                doc = inspect.getdoc(method) or \"No description available\"\n                \n                # Parse parameters\n                parameters = {}\n                required = []\n                \n                for param_name, param in sig.parameters.items():\n                    # Skip self parameter\n                    if param_name == 'self':\n                        continue\n                    \n                    # Determine parameter type\n                    param_type = \"string\"  # Default type\n                    if param.annotation != inspect.Parameter.empty:\n                        if param.annotation == str:\n                            param_type = \"string\"\n                        elif param.annotation == int:\n                            param_type = \"number\"\n                        elif param.annotation == bool:\n                            param_type = \"boolean\"\n                        elif param.annotation == dict or param.annotation == list:\n                            param_type = \"object\"\n                    \n                    # Create parameter definition\n                    parameters[param_name] = {\n                        \"type\": param_type,\n                        \"description\": f\"Parameter for {name}: {param_name}\"\n                    }\n                    \n                    # Add to required parameters if no default value\n                    if param.default == inspect.Parameter.empty:\n                        required.append(param_name)\n                \n                # Register the tool\n                tools[name] = {\n                    \"function\": method,\n                    \"description\": doc,\n                    \"parameters\": parameters,\n                    \"required\": required\n                }\n        \n        return tools\n    \n    def _format_tools_for_api(self):\n        \"\"\"Format tools for the Claude API.\"\"\"\n        tools = []\n        \n        for name, tool in self.available_tools.items():\n            # Create properties dictionary for parameters\n            properties = {}\n            for param_name, param_info in tool[\"parameters\"].items():\n                properties[param_name] = {\n                    \"type\": param_info[\"type\"],\n                    \"description\": param_info[\"description\"]\n                }\n            \n            # Create tool definition\n            tool_def = {\n                \"name\": name,\n                \"description\": tool[\"description\"],\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": properties\n                }\n            }\n            \n            # Add required parameters if any\n            if tool[\"required\"]:\n                tool_def[\"parameters\"][\"required\"] = tool[\"required\"]\n            \n            # Add to tools list\n            tools.append(tool_def)\n        \n        return tools\n    \n    def _execute_tool(self, tool_name, parameters):\n        \"\"\"Execute a tool with the given parameters.\"\"\"\n        if tool_name not in self.available_tools:\n            return {\"error\": f\"Tool not found: {tool_name}\"}\n        \n        try:\n            # Get the tool function\n            tool_func = self.available_tools[tool_name][\"function\"]\n            \n            # Execute the function with the parameters\n            result = tool_func(**parameters)\n            \n            return {\"result\": result}\n        except Exception as e:\n            return {\"error\": f\"Error executing tool {tool_name}: {str(e)}\"}\n    \n    def ask_claude(self, prompt, system_prompt, messages=None, with_tools=True):\n        \"\"\"\n        Send a prompt to Claude API and return the response.\n        \n        Args:\n            prompt: The user's prompt \n            system_prompt: The system prompt\n            messages: Previous messages (optional)\n            with_tools: Whether to enable tool use (default: True)\n            \n        Returns:\n            A dictionary containing Claude's response\n        \"\"\"\n        try:\n            # Prepare the API request\n            headers = {\n                \"x-api-key\": self.api_key,\n                \"anthropic-version\": \"2023-06-01\",\n                \"content-type\": \"application/json\"\n            }\n            \n            # Format the messages\n            if messages:\n                message_list = messages\n            else:\n                message_list = [{\"role\": \"user\", \"content\": prompt}]\n            \n            # Create the request payload\n            payload = {\n                \"model\": self.model,\n                \"system\": system_prompt,\n                \"messages\": message_list,\n                \"max_tokens\": self.max_tokens\n            }\n            \n            # Add tools if requested\n            if with_tools:\n                payload[\"tools\"] = self._format_tools_for_api()\n            \n            # Send the request\n            response = requests.post(\n                self.api_url,\n                headers=headers,\n                json=payload\n            )\n            \n            # Check for errors\n            response.raise_for_status()\n            response_data = response.json()\n            \n            # Extract the response text\n            response_text = \"\"\n            tool_calls = []\n            \n            for content in response_data.get(\"content\", []):\n                if content[\"type\"] == \"text\":\n                    response_text += content[\"text\"]\n                elif content[\"type\"] == \"tool_use\":\n                    # Store tool use information\n                    tool_calls.append({\n                        \"id\": content[\"id\"],\n                        \"name\": content[\"name\"],\n                        \"parameters\": content[\"input\"]\n                    })\n            \n            # If there are tool calls, process them\n            if tool_calls:\n                return self._process_tool_calls(response_data, tool_calls, system_prompt, message_list)\n            \n            # No tool calls, just return the response\n            result = {\n                \"thinking\": \"\",\n                \"response\": response_text\n            }\n            \n            self.last_response = result\n            return result\n            \n        except Exception as e:\n            error_msg = f\"Error communicating with Claude API: {str(e)}\"\n            result = {\n                \"thinking\": \"\",\n                \"response\": error_msg\n            }\n            self.last_response = result\n            return result\n    \n    def _process_tool_calls(self, initial_response, tool_calls, system_prompt, messages):\n        \"\"\"Process tool calls in Claude's response.\"\"\"\n        initial_text = \"\"\n        tool_outputs = []\n        \n        # Extract initial text response\n        for content in initial_response.get(\"content\", []):\n            if content[\"type\"] == \"text\":\n                initial_text += content[\"text\"]\n        \n        # Process each tool call\n        for tool_call in tool_calls:\n            tool_name = tool_call[\"name\"]\n            tool_params = tool_call[\"parameters\"]\n            \n            # Execute the tool and get result\n            tool_result = self._execute_tool(tool_name, tool_params)\n            \n            # Add to outputs\n            tool_outputs.append({\n                \"tool_call_id\": tool_call[\"id\"],\n                \"output\": json.dumps(tool_result)\n            })\n        \n        # If there are tool outputs, send a follow-up request\n        if tool_outputs:\n            try:\n                # Prepare headers\n                headers = {\n                    \"x-api-key\": self.api_key,\n                    \"anthropic-version\": \"2023-06-01\",\n                    \"content-type\": \"application/json\"\n                }\n                \n                # Create follow-up payload\n                follow_up_payload = {\n                    \"model\": self.model,\n                    \"system\": system_prompt,\n                    \"messages\": messages,\n                    \"max_tokens\": self.max_tokens,\n                    \"tool_outputs\": tool_outputs\n                }\n                \n                # Send follow-up request\n                follow_up_response = requests.post(\n                    self.api_url,\n                    headers=headers,\n                    json=follow_up_payload\n                )\n                \n                # Check for errors\n                follow_up_response.raise_for_status()\n                follow_up_data = follow_up_response.json()\n                \n                # Extract follow-up response\n                follow_up_text = \"\"\n                for content in follow_up_data.get(\"content\", []):\n                    if content[\"type\"] == \"text\":\n                        follow_up_text += content[\"text\"]\n                \n                result = {\n                    \"thinking\": \"\",\n                    \"response\": follow_up_text,\n                    \"tool_calls\": tool_calls,\n                    \"tool_outputs\": tool_outputs\n                }\n                \n                self.last_response = result\n                return result\n                \n            except Exception as e:\n                error_msg = f\"Error processing tool calls: {str(e)}\"\n                result = {\n                    \"thinking\": \"\",\n                    \"response\": error_msg + \"\\n\\nInitial response: \" + initial_text,\n                    \"tool_calls\": tool_calls\n                }\n                self.last_response = result\n                return result\n        \n        # No tool outputs to process\n        result = {\n            \"thinking\": \"\",\n            \"response\": initial_text,\n            \"tool_calls\": tool_calls\n        }\n        \n        self.last_response = result\n        return result\n    \n    def read_response(self):\n        \"\"\"Return the last response.\"\"\"\n        return self.last_response or {\"thinking\": \"\", \"response\": \"No previous response available.\"}\n```\n\nNow, let's implement the improved code manager that properly handles dependencies:\n\n```python\n# filename: utils/code_manager.py\nimport os\nimport re\nimport shutil\nimport datetime\nfrom config import TEST_DIR, VERSIONS_DIR\nfrom utils.commands import Commands\n\nclass CodeManager:\n    def __init__(self):\n        \"\"\"Initialize the CodeManager.\"\"\"\n        self.main_dir = \".\"\n        self.test_dir = TEST_DIR\n        self.backup_dir = VERSIONS_DIR\n        \n        # Ensure required directories exist\n        Commands.create_directory(TEST_DIR)\n        Commands.create_directory(VERSIONS_DIR)\n        \n    def get_file_content(self, filepath):\n        \"\"\"Read the content of a file if it exists.\"\"\"\n        try:\n            with open(filepath, 'r', encoding='utf-8') as f:\n                return f.read()\n        except Exception as e:\n            return f\"Error reading file {filepath}: {str(e)}\"\n            \n    def get_current_code(self, file_path=\"main.py\"):\n        \"\"\"Get the contents of the specified file.\"\"\"\n        return self.get_file_content(file_path)\n            \n    def extract_code_from_response(self, response):\n        \"\"\"Extract code blocks from a Claude response.\"\"\"\n        if not isinstance(response, dict) or \"response\" not in response:\n            return {}\n            \n        text = response[\"response\"]\n        code_files = {}\n        \n        # Pattern to match Python code blocks with filename indicators\n        # Looks for: ```python (or ```), then captures the code content\n        code_blocks = re.findall(r'```(?:python)?\\s*\\n(.*?)\\n```', text, re.DOTALL)\n\n        for i, block in enumerate(code_blocks):\n            # Look for filename indicators in each code block\n            filename_match = re.search(r'^\\s*#\\s*filename:\\s*([^\\n]+)', block, re.MULTILINE)\n            if filename_match:\n                filename = filename_match.group(1).strip()\n                # Remove the filename line from the code\n                code = re.sub(r'^\\s*#\\s*filename:\\s*[^\\n]+\\n?', '', block, flags=re.MULTILINE)\n                code_files[filename] = code.strip()\n                continue\n                \n            # Alternative filename format\n            filename_match = re.search(r'^\\s*#\\s*([a-zA-Z0-9_\\/\\\\]+?\\.[a-zA-Z0-9]+)', block, re.MULTILINE)\n            if filename_match:\n                filename = filename_match.group(1)\n                code_files[filename] = block.strip()\n                continue\n\n            # Try to detect filenames from class definitions\n            class_match = re.search(r\"class\\s+(\\w+)\", block)\n            if class_match:\n                class_name = class_match.group(1)\n                # If it's the main assistant class\n                if class_name == \"SelfImprovingAssistant\":\n                    filename = \"main.py\"\n                else:\n                    # Convert CamelCase to snake_case for the filename\n                    filename = ''.join(['_'+c.lower() if c.isupper() else c.lower() for c in class_name]).lstrip('_')\n                    filename = f\"utils/{filename}.py\"\n                \n                # Check if this file already exists in the project\n                existing_content = self.get_file_content(filename)\n                if \"Error reading file\" not in str(existing_content):\n                    print(f\"Found existing file for class {class_name}: {filename}\")\n                    code_files[filename] = block.strip()\n                    continue\n            \n            # Default case if no filename can be determined\n            if len(code_blocks) == 1:\n                # If only one code block, assume it's main.py\n                filename = \"main.py\"\n            else:\n                # Generate a name based on block position\n                filename = f\"generated_code_{i+1}.py\"\n            \n            code_files[filename] = block.strip()\n        \n        # Read the original content of each file to understand what we're modifying\n        for filename in list(code_files.keys()):\n            original_content = self.get_file_content(filename)\n            if \"Error reading file\" not in str(original_content):\n                print(f\"Reading original file before modification: {filename}\")\n        \n        return code_files\n        \n    def deploy_to_test(self, code_files):\n        \"\"\"Deploy code files to test environment, including unchanged files.\"\"\"\n        # Clear the test directory first\n        if os.path.exists(self.test_dir):\n            shutil.rmtree(self.test_dir)\n        os.makedirs(self.test_dir, exist_ok=True)\n        \n        # First, copy all existing project files to ensure all dependencies are available\n        print(\"Copying all project files to test environment...\")\n        for root, dirs, files in os.walk(self.main_dir):\n            # Skip directories we don't want to copy\n            if any(excluded in root for excluded in [\n                self.test_dir, \".git\", \"__pycache__\", self.backup_dir\n            ]):\n                continue\n                \n            for file in files:\n                # Skip non-Python files or specific files we don't want to copy\n                if not file.endswith(\".py\"):\n                    continue\n                    \n                # Get original file path and determine destination path\n                src_path = os.path.join(root, file)\n                # Maintain directory structure in test directory\n                rel_path = os.path.relpath(src_path, self.main_dir)\n                dst_path = os.path.join(self.test_dir, rel_path)\n                \n                # Create directories if needed\n                os.makedirs(os.path.dirname(dst_path), exist_ok=True)\n                \n                # Copy the file\n                shutil.copy2(src_path, dst_path)\n        \n        # Now override with our new files\n        print(\"Applying changes to test environment...\")\n        for filename, content in code_files.items():\n            # Determine the destination path \n            dst_path = os.path.join(self.test_dir, filename)\n            \n            # Create directories if needed\n            os.makedirs(os.path.dirname(dst_path), exist_ok=True)\n            \n            # Write the new content\n            with open(dst_path, 'w', encoding='utf-8') as f:\n                f.write(content)\n                \n        return self.test_dir\n        \n    def test_new_code(self):\n        \"\"\"Run tests on the new code.\"\"\"\n        # Simple test: try to run main.py in test mode\n        try:\n            import subprocess\n            \n            # Navigate to test directory and run main.py with --test flag\n            result = subprocess.run(\n                [\"python\", \"main.py\", \"--test\"],\n                cwd=self.test_dir,\n                capture_output=True,\n                text=True,\n                timeout=30\n            )\n            \n            success = result.returncode == 0\n            output = result.stdout + \"\\n\" + result.stderr\n            \n            return {\n                \"success\": success,\n                \"output\": output\n            }\n        except Exception as e:\n            return {\n                \"success\": False,\n                \"output\": f\"Error running tests: {str(e)}\"\n            }\n            \n    def deploy_to_production(self, code_files):\n        \"\"\"Deploy code files to production after testing.\"\"\"\n        # Create a backup of current code first\n        backup_timestamp = self._create_backup()\n        \n        # Deploy each file\n        deployed_files = []\n        for filename, content in code_files.items():\n            # Determine the destination path \n            dst_path = os.path.join(self.main_dir, filename)\n            \n            # Create directories if needed\n            os.makedirs(os.path.dirname(dst_path), exist_ok=True)\n            \n            # Write the new content\n            with open(dst_path, 'w', encoding='utf-8') as f:\n                f.write(content)\n                \n            deployed_files.append(filename)\n            \n        return {\n            \"success\": True,\n            \"message\": f\"Successfully deployed {len(deployed_files)} files to production. Backup created at {backup_timestamp}.\",\n            \"deployed_files\": deployed_files,\n            \"backup\": backup_timestamp\n        }\n        \n    def _create_backup(self):\n        \"\"\"Create a backup of the current code.\"\"\"\n        from datetime import datetime\n        \n        # Create a timestamp for the backup\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        backup_dir = os.path.join(self.backup_dir, timestamp)\n        \n        # Create the backup directory\n        os.makedirs(backup_dir, exist_ok=True)\n        \n        # Copy all Python files from the main directory to the backup\n        for root, dirs, files in os.walk(self.main_dir):\n            # Skip directories we don't want to backup\n            if any(excluded in root for excluded in [\n                self.test_dir, \".git\", \"__pycache__\", self.backup_dir\n            ]):\n                continue\n                \n            for file in files:\n                # Only backup Python files\n                if not file.endswith(\".py\"):\n                    continue\n                    \n                # Get original file path and determine destination path\n                src_path = os.path.join(root, file)\n                # Maintain directory structure in backup\n                rel_path = os.path.relpath(src_path, self.main_dir)\n                dst_path = os.path.join(backup_dir, rel_path)\n                \n                # Create directories if needed\n                os.makedirs(os.path.dirname(dst_path), exist_ok=True)\n                \n                # Copy the file\n                shutil.copy2(src_path, dst_path)\n                \n        return timestamp\n```\n\nFinally, let's update the main.py file to support the function calling capabilities:\n\n```python\n# filename: main.py\nimport os\nimport json\nimport argparse\n# Import modules\nfrom utils.commands import Commands\nfrom utils.claude_api import ClaudeAPI\nfrom utils.state import StateManager\nfrom utils.code_manager import CodeManager\nfrom config import HISTORY_FILE, VERSION\n\nclass SelfImprovingAssistant:\n    def __init__(self):\n        self.commands = Commands()\n        self.claude_api = ClaudeAPI()\n        self.state_manager = StateManager()\n        self.code_manager = CodeManager()\n        self.try_number = 1\n        \n        # Create necessary directories if they don't exist\n        self.ensure_directories()\n        \n        # Initialize state with current version\n        self.state_manager.state[\"version\"] = VERSION\n        self.state_manager.save_state()\n        \n    def ensure_directories(self):\n        \"\"\"Ensure all necessary directories exist.\"\"\"\n        directories = [\"versions\", \"test\", \"utils\", \"tests\", \"data\"]\n        for directory in directories:\n            if not os.path.exists(directory):\n                Commands.create_directory(directory)\n                    \n    def format_answer(self, response):\n        \"\"\"Format a Claude response for display and saving.\"\"\"\n        result = \"\"\n        if isinstance(response, dict):\n            if \"thinking\" in response and response[\"thinking\"]:\n                result += \"## Claude thinking:\\n\"  \n                result += response[\"thinking\"] + \"\\n\\n\"\n            if \"response\" in response and response[\"response\"]:\n                result += \"## Claude's response:\\n\"\n                result += response[\"response\"]\n            \n            # Add tool calls if any\n            if \"tool_calls\" in response and response[\"tool_calls\"]:\n                result += \"\\n\\n## Tool calls used:\\n\"\n                for tool_call in response[\"tool_calls\"]:\n                    result += f\"- {tool_call['name']}({json.dumps(tool_call['parameters'])})\\n\"\n        else:\n            result = f\"## Error:\\n{str(response)}\"\n\n        return result + \"\\n\\n\"\n        \n    def append_to_history(self, text):\n        \"\"\"Append text to the history file.\"\"\"\n        Commands.append_file(HISTORY_FILE, text)\n\n    def print_and_save_answer(self, prompt, answer):\n        \"\"\"Print and save a formatted answer to history.\"\"\"\n        result = f\"# Try {self.try_number}\\n## Prompt:\\n{prompt}\\n\\n\"\n        result += self.format_answer(answer)\n        self.append_to_history(result)\n        print(result)\n        self.try_number += 1\n        \n    def implement_code_changes(self, response):\n        \"\"\"Extract and implement code changes from a Claude response.\"\"\"\n        print(\"Analyzing response for code changes...\")\n        \n        # Extract code from response\n        code_files = self.code_manager.extract_code_from_response(response)\n        \n        if not code_files:\n            print(\"No code changes detected in the response.\")\n            return False\n            \n        print(f\"Found {len(code_files)} code files in response:\")\n        for filename in code_files:\n            print(f\" - {filename}\")\n            \n        # Deploy to test environment first (with all dependencies)\n        print(\"\\nDeploying to test environment...\")\n        test_dir = self.code_manager.deploy_to_test(code_files)\n        \n        # Run tests\n        print(\"Running tests on new code...\")\n        test_result = self.code_manager.test_new_code()\n        print(f\"Test result: {test_result['output']}\")\n        \n        # If tests passed, deploy to production\n        if test_result[\"success\"]:\n            print(\"\\nTests passed. Deploying to production...\")\n            result = self.code_manager.deploy_to_production(code_files)\n            print(result[\"message\"])\n            \n            # Log the successful implementation\n            self.state_manager.log_execution(\n                \"code_implementation\", \n                {\"files\": list(code_files.keys()), \"test_output\": test_result[\"output\"]}\n            )\n            return True\n        else:\n            print(\"\\nTests failed. Not deploying to production.\")\n            return False\n        \n    def get_current_code_prompt(self):\n        \"\"\"Generate a prompt with the current code.\"\"\"\n        current_code = self.code_manager.get_current_code()\n        return f\"This is your current code:\\n```python\\n{current_code}\\n```\\n\"\n    \n    def read_command_from_file(self, command_input):\n        \"\"\"\n        Read a command from a file.\n        \n        Args:\n            command_input (str): The command input that may contain a filename\n            \n        Returns:\n            str: The content of the file, or None if there was an error\n        \"\"\"\n        # Parse the command to get the filename\n        parts = command_input.split(maxsplit=1)\n        filename = \"next_command.txt\"  # Default filename\n        \n        # If a filename was provided, use it instead\n        if len(parts) > 1:\n            filename = parts[1]\n        \n        try:\n            # Read the content from the file\n            with open(filename, 'r') as file:\n                content = file.read()\n            print(f\"Read command from {filename}: {content}\")\n            return content\n        except Exception as e:\n            print(f\"Error reading from {filename}: {str(e)}\")\n            return None\n            \n    def get_multiline_input(self):\n        \"\"\"\n        Get multiline input from the user.\n        \n        The user can enter multiple lines of text until they enter the\n        termination sequence 'END' on a line by itself.\n        \n        Returns:\n            str: The multiline input as a single string\n        \"\"\"\n        print(\"Enter multiline input (type 'END' on a line by itself to finish):\")\n        lines = []\n        while True:\n            line = input(\"> \")\n            if line.strip() == \"END\":\n                break\n            lines.append(line)\n        \n        # Join the lines with newlines\n        return \"\\n\".join(lines)\n        \n    def run(self, test_mode=False):\n        \"\"\"Main execution loop.\"\"\"\n        if test_mode:\n            print(\"Running in test mode - validating functionality...\")\n            # Perform basic validation\n            print(\"- State manager:\", \"OK\" if self.state_manager else \"ERROR\")\n            print(\"- Claude API:\", \"OK\" if self.claude_api else \"ERROR\")\n            print(\"- Code manager:\", \"OK\" if self.code_manager else \"ERROR\")\n            print(\"Test completed successfully!\")\n            return True\n            \n        print(f\"Reto's Self-Improving Assistant v{VERSION}\\n\")\n        print(\"--------------------------------\")\n        print(\"Type 'quit' to exit, 'implement' to force implementation of code\")\n        print(\"Special commands:\")\n        print(\"  /multiline or /ml - Enter multiline input mode\")\n        print(\"  /readcommand or /readcmd - Read command from a file\")\n        print(\"  /tools on|off - Enable or disable function calling\\n\")\n        \n        # Default to enabling tools\n        enable_tools = True\n        \n        while True:\n            # Get the current code to show to Claude\n            prompt_start = self.get_current_code_prompt()\n            \n            # Get user input\n            user_input = input(\"Reto's comment: \")\n            if user_input == \"\":\n                user_input = \"Ok. Write the next version of yourself.\"\n            \n            # Handle multiline input\n            if user_input.lower() in ['/multiline', '/ml']:\n                user_input = self.get_multiline_input()\n                print(f\"Received multiline input ({len(user_input.splitlines())} lines)\")\n            \n            # Handle /readcommand or /readcmd\n            elif user_input.lower().startswith('/readcommand') or user_input.lower().startswith('/readcmd'):\n                file_content = self.read_command_from_file(user_input)\n                if file_content is not None:\n                    user_input = file_content\n                else:\n                    continue  # Skip this iteration and prompt for input again\n            \n            # Handle /tools command\n            elif user_input.lower().startswith('/tools'):\n                parts = user_input.lower().split()\n                if len(parts) > 1:\n                    if parts[1] == \"on\":\n                        enable_tools = True\n                        print(\"Function calling enabled\")\n                    elif parts[1] == \"off\":\n                        enable_tools = False\n                        print(\"Function calling disabled\")\n                    else:\n                        print(f\"Invalid option for /tools: {parts[1]}\")\n                else:\n                    print(f\"Function calling is currently {'enabled' if enable_tools else 'disabled'}\")\n                continue\n            \n            # Handle quit commands\n            if user_input.lower() in ['/quit', 'quit', 'exit', '/exit']:\n                print(\"Goodbye!\")\n                break\n                \n            # Construct the full prompt\n            prompt = prompt_start + \"\\nReto's input: \" + user_input\n            \n            # Update state with user message\n            self.state_manager.add_message(\"user\", prompt)\n            \n            # Get response from Claude\n            if user_input.lower() == '/retry':\n                response = self.claude_api.read_response()\n            else:\n                # Get the current system prompt that includes our state\n                system_prompt = self.state_manager.update_system_prompt()\n                messages = self.state_manager.get_messages_for_api()\n                response = self.claude_api.ask_claude(prompt, system_prompt, messages, with_tools=enable_tools)\n                # Update state with Claude's response\n                if isinstance(response, dict) and \"response\" in response:\n                    self.state_manager.add_message(\"assistant\", response[\"response\"])\n                \n            # Print and save the response\n            self.print_and_save_answer(prompt, response)\n            \n            do_changes = input(\"Do you want to implement the changes? (y/n): \")\n            if do_changes.lower() in ['y', 'yes']:\n                self.implement_code_changes(response)\n            else:\n                print(\"Ok. Let's continue.\")\n            \ndef main():\n    # Parse command line arguments\n    parser = argparse.ArgumentParser(description=\"Self-Improving Assistant\")\n    parser.add_argument(\"--test\", action=\"store_true\", help=\"Run in test mode to validate functionality\")\n    args = parser.parse_args()\n    \n    # Initialize and run the assistant\n    assistant = SelfImprovingAssistant()\n    assistant.run(test_mode=args.test)\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThese changes accomplish the following:\n\n1. Added function calling capability to the `ClaudeAPI` class:\n   - Automatically registers all Commands static methods as available tools\n   - Dynamically builds parameter definitions based on method signatures\n   - Properly handles execution of tools and follow-up responses\n   - Supports toggling function calling on/off with `/tools` command\n\n2. Enhanced the `CodeManager` class to correctly handle dependencies:\n   - Reads original file content before making changes\n   - Copies all project files to the test directory before testing\n   - Maintains proper directory structure in test environment\n   - Properly backs up all files in versioned backups\n\n3. Updated the main application to:\n   - Support the function calling features\n   - Display tool usage information in responses\n   - Toggle tools with new `/tools on|off` command\n\nThis implementation ensures that when changing files, we properly maintain dependencies and backward compatibility."
}