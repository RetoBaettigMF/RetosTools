<!DOCTYPE html>
<html>
    <head>
        <title>Cudos Trail : SI Professional Zertifikat</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Cudos Trail</a></span>
                            </li>
                                                    <li>
                                <span><a href="Cudos-Trail-Startseite_5639668934.html">Cudos Trail Startseite</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Cudos Trail : SI Professional Zertifikat
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Rachel Blaser</span> on Feb. 02, 2021
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <p>Dieses Vorbereitungsdokument fürs SI Professional Zertifikat wurde von Florian Gubler verfasst.</p><h1 id="SIProfessionalZertifikat-Themenbereiche">Themenbereiche</h1><ul><li>Software-Entwicklung (z.B. Design Patterns)</li><li>Relationale Datenbanken (relationale Algebra)</li><li>Unternehmensmodellierung</li><li>Begriffe aus dem Projektmanagement, Scrum, etc.</li><li>Intelligenztest: Folgt irgendeinem ISO Standard:<ul><li>Ein Teil Kopfrechnen</li><li>Ein Teil Muster in Zahlenreihen erkennen</li><li>Ein Teil geometrische Formen aus kleineren Teil-Formen zusammensetzen</li><li>Ein Teil Muster in einer Spiegelung einer geometrischen Form erkennen und auf eine Andere anwenden.</li></ul></li></ul><h1 id="SIProfessionalZertifikat-RelationaleDatenbank-Theorie">Relationale Datenbank-Theorie</h1><h2 id="SIProfessionalZertifikat-Normalformen">Normalformen</h2><ol><li><em> </em><em>Jedes Attribut der Relation muss einen atomaren Wertebereich haben, und die Relation muss frei von Wiederholungsgruppen sein.</em><ul><li>Spalten dürfen nur primitive Datentypen haben, welche nicht weiter zerlegt werden können (z.B. nicht ein JSON, eine Komma-Separierte Liste oder ein ganzes Objekt).</li><li>Somit müssen komplexere Datenstrukturen aufgebrochen und auf mehrere Spalten verteilt werden.</li></ul></li><li><em> </em><em>Eine Relation ist genau dann in der zweiten Normalform, wenn die erste Normalform vorliegt und kein Nichtprimärattribut (Attribut, das nicht Teil eines Schlüsselkandidaten ist) funktional von einer echten Teilmenge eines Schlüsselkandidaten abhängt.</em><ul><li>Mit der <em>Teilmenge eines Schlüsselkandidaten</em> ist gemeint, dass ein Unique-Key ja aus mehreren Spalten zusammengesetzt sein kann. Wenn alle Unique-Keys aus jeweils nur einer Spalte bestehen, ist die Normalform automatisch erfüllt.</li><li>Das bedeutet, dass ein Spaltenwert nur aus einem kompletten Unique-Key herleitbar sein darf; aber nicht nur aus einem Teil davon.</li><li>Angenommen, wir haben eine Tabelle mit Smartphone-Modellen mit einem Unique-Key, der aus dem Hersteller und der Modellnummer besteht. Zusätzlich gibt es eine Spalte «Betriebssystem» (Mit den Werten «Android» oder «iOS», ohne Versionsnummern).<ul><li>Für die Bestimmung des Betriebssystems reicht der Hersteller (z.B. im Fall von Apple) aus. Es wird also nicht der gesamte Unique-Key benötigt und die Normalform ist verletzt.</li></ul></li><li>Somit müsste die Tabelle in mehrere Tabellen aufgebrochen werden.</li></ul></li><li><em> </em><em>Die dritte Normalform ist genau dann erreicht, wenn sich das Relationenschema in der 2NF befindet, und kein Nichtschlüsselattribut von einem Schlüsselkandidaten transitiv abhängt.</em><ul><li>Das bedeutet, dass Spaltenwerte nur aus Unique-Keys herleitbar sein dürfen, aber nicht aus anderen Spalten.</li><li>Beispielsweise dürfte man nicht eine Adress-Tabelle bauen, welche Adress-ID (PK), Land, Kanton, Stadt und Strasse als Spalten abbildet. Das Land lässt sich aus dem Kanton herleiten, der Kanton aus der Stadt und die Stadt aus der Strasse (angenommen, die Namen sind eindeutig).</li><li>Somit müsste die Tabelle in mehrere Tabellen aufgebrochen werden.</li></ul></li></ol><h2 id="SIProfessionalZertifikat-Transaktionen&amp;ACID">Transaktionen &amp; ACID</h2><p>Datenbank-Transaktionen sollen die ACID Regeln erfüllen:</p><ul><li><strong>Atomicity</strong>: Eine Transaktion kann mehrere Operationen enthalten, garantiert jedoch, dass immer entweder alle Operationen (valid) ausgeführt werden oder gar keine: Es können keine Zwischenzustände entstehen (auch bei z.B. Stromausfällen, Fehlern, etc.).</li><li><strong>Consistency</strong>: Eine Transaktion kann eine Datenbank nur von einem validen (gültigen) Zustand in einen neuen gültigen Zustand bringen. Die Transaktion resultiert also nie in ungültigen Datenbank-Zuständen.<ul><li>Die Gültigkeit (Validität) bezieht sich auf die Datenbank-Invarianten wie z.B. Datentypen, Constraints, Kaskaden, Trigger, etc. und nicht auf inhaltliche/fachliche Korrektheit.</li></ul></li><li><strong>Isolation</strong>: Die Änderungen einer Transaktion werden erst sichtbar, wenn sie abgeschlossen ist. Andere, parallel-laufende Transaktionen bekommen davon nichts mit.</li><li><strong>Durability</strong>: Sobald eine Transaktion erfolgreich abgeschlossen und <em>commited</em> ist, bleibt ihr Resultat dauerhaft bestehen, auch wenn danach z.B. das System abstürzt.</li></ul><h1 id="SIProfessionalZertifikat-Netzwerktheorie">Netzwerktheorie</h1><h2 id="SIProfessionalZertifikat-OSIModel">OSI Model</h2><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p>Layer</p></td><td class="confluenceTd"><p>Beschreibung &amp; Beispiele</p></td></tr><tr><td class="confluenceTd"><p>7</p></td><td class="confluenceTd"><p>Application Layer</p></td><td class="confluenceTd"><p>Interaktion mit Nutzer; z.B. HTTP, SMTP, DNS, etc.</p></td></tr><tr><td class="confluenceTd"><p>6</p></td><td class="confluenceTd"><p>Presentation Layer</p></td><td class="confluenceTd"><p>Datenaufbereitung: Ver- &amp; Entschlüsselung, Komprimierung, etc.</p></td></tr><tr><td class="confluenceTd"><p>5</p></td><td class="confluenceTd"><p>Session Layer</p></td><td class="confluenceTd"><p>Öffnet, erhaltet und schliesst Sessions zwischen Geräten.</p></td></tr><tr><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>Transport Layer</p></td><td class="confluenceTd"><p>Datenübertragung (Acknowledgements, erneut senden, etc.); <br/>TCP und UDP</p></td></tr><tr><td class="confluenceTd"><p>3</p></td><td class="confluenceTd"><p>Network Layer</p></td><td class="confluenceTd"><p>Schickt Netzwerk-Packages und übernimmt das Routing.</p></td></tr><tr><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>Datalink Layer</p></td><td class="confluenceTd"><p>Kommunikation mit Frames innerhalb eines Netzwerks anhand von MAC</p></td></tr><tr><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>Physical Layer</p></td><td class="confluenceTd"><p>Physische Übertragung von Bits als 1 oder 0; z.B. Ethernet vs. WiFi</p></td></tr></tbody></table></div><h2 id="SIProfessionalZertifikat-InternetModel">Internet Model</h2><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><br/></p></td><td class="confluenceTd"><p>Layer</p></td><td class="confluenceTd"><p>Beschreibung &amp; Beispiele</p></td></tr><tr><td class="confluenceTd"><p>4</p></td><td class="confluenceTd"><p>Application Layer</p></td><td class="confluenceTd"><p>Beinhaltet <em>Application</em>, <em>Presentation</em> und <em>Session Layer</em></p></td></tr><tr><td class="confluenceTd"><p>3</p></td><td class="confluenceTd"><p>Transport Layer</p></td><td class="confluenceTd"><p>Entspricht dem <em>Transport Layer</em></p></td></tr><tr><td class="confluenceTd"><p>2</p></td><td class="confluenceTd"><p>Internet Layer</p></td><td class="confluenceTd"><p>Entspricht dem <em>Network Layer</em> (Routing, etc.); IP,</p></td></tr><tr><td class="confluenceTd"><p>1</p></td><td class="confluenceTd"><p>Link Layer</p></td><td class="confluenceTd"><p>Beinhaltet den <em>Data Link</em> und <em>Physical Layer</em></p></td></tr></tbody></table></div><h1 id="SIProfessionalZertifikat-Sortierungsalgorithmen">Sortierungsalgorithmen</h1><h2 id="SIProfessionalZertifikat-Übersicht">Übersicht</h2><p><br/></p><div class="table-wrap"><table class="confluenceTable"><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td class="confluenceTd"><p>Algorithmus</p></td><td class="confluenceTd"><p>Best</p></td><td class="confluenceTd"><p>Average</p></td><td class="confluenceTd"><p>Worst</p></td><td class="confluenceTd"><p>Stable</p></td></tr><tr><td class="confluenceTd"><p>Quick Sort</p></td><td class="confluenceTd">n * log(n)</td><td class="confluenceTd">n * log(n)</td><td class="confluenceTd">n<sup>2</sup></td><td class="confluenceTd"><p>Nein</p></td></tr><tr><td class="confluenceTd"><p>Merge Sort</p></td><td class="confluenceTd">n * log(n)</td><td class="confluenceTd">n * log(n)</td><td class="confluenceTd">n * log(n)</td><td class="confluenceTd"><p>Ja</p></td></tr><tr><td class="confluenceTd"><p>Heap Sort</p></td><td class="confluenceTd">n * log(n)</td><td class="confluenceTd">n * log(n)</td><td class="confluenceTd">n * log(n)</td><td class="confluenceTd"><p>Nein</p></td></tr><tr><td class="confluenceTd"><p>Tree Sort</p></td><td class="confluenceTd">n * log(n)</td><td class="confluenceTd">n * log(n)</td><td class="confluenceTd"><p>n * log(n)<br/>(if balanced)</p></td><td class="confluenceTd"><p>Ja</p></td></tr></tbody></table></div><p>Stable bedeutet, dass die Reihenfolge «gleicher» Elemente erhalten bleibt.</p><h2 id="SIProfessionalZertifikat-Quicksort">Quicksort</h2><ul><li>Definiere ein Pivot-Element an Position i (z.B. in der Mitte)</li><li>Daraus entstehen zwei (implizite) Sub-Arrays [0, i-1] und [i+1, n]</li><li>Verschiebe alle Elemente, die grösser sind als das Pivot-Element in das rechte Array und alle, die kleiner sind, in das linke Array.</li><li>Wiederhole das ganze rekursiv für die Sub-Arrays.</li><li>Schwachpunkt: Falls dummerweise immer genau das grösste oder kleinste Element als Pivot gewählt wird, ist die Komplexität weil eines der beiden Sub-Arrays jeweils nur 1 Element enthält.</li></ul><h2 id="SIProfessionalZertifikat-MergeSort">Merge Sort</h2><ul><li>Unterteile das Array in n Subarrays der Länge 1</li><li>Merge rekursiv jeweils 2 Subarrays in ein grösseres Array und sortiere es dabei. Beachte: Die Subarrays sind immer bereits sortiert (vom vorherigen Schritt)<ul><li>Vergleiche das erste Element von Subarray A mit dem ersten von Subarray B</li><li>Nehme das kleinere als erstes Element vom neuen Array</li><li>Vergleiche das neu kleinste Element von Subarray A mit dem kleinsten von B und nehme das kleinere als zweites Element des neuen Arrays. Etc.</li></ul></li><li>Mache das so lange bis es nur noch ein Array gibt.</li></ul><h2 id="SIProfessionalZertifikat-TreeSort">Tree Sort</h2><ul><li>Baue einen Binärbaum wobei alle Knoten im linken Unterbaum kleiner sind als die Wurzel und alle Knoten im rechten Unterbaum grösser.</li><li>Fange mit einer Wurzel an und dann gehe ich mit jedem neuen Element durch den Baum und hänge es an die richtige Stelle: Falls das Element kleiner ist, gehe in den linken Unterbaum navigieren, sonst in den Rechten.<ul><li>Wenn wir ein Blatt erreichen, hänge das Element als neuen Sub-Knoten ein.</li></ul></li><li>Nehme einen <em>Self-balancing Binary Search Tree</em>, um zu verhindern, dass dabei eine Kette (Linked-List) entsteht, wenn z.B. die Wurzel falsch gewählt ist oder die Elemente alle gleich sind. Sonst kann schlimmstenfalls eine Komplexität auftreten.</li></ul>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Okt. 15, 2024 12:04</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
